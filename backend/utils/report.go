// filepath: e:\Masters\CMPE209-project\PacketGuardian-LLM\backend\utils\report.go
package utils

import (
	"bytes"
	"fmt"
	"strings"

	"github.com/jung-kurt/gofpdf"
)

// GeneratePDFReport creates a PDF report from the analysis results
func GeneratePDFReport(result string) ([]byte, error) {
	// Create a new PDF with A4 dimensions
	pdf := gofpdf.New("P", "mm", "A4", "")

	// Add a page
	pdf.AddPage()

	// Set font
	pdf.SetFont("Arial", "B", 16)

	// Title
	pdf.Cell(40, 10, "Packet Analysis Report")
	pdf.Ln(15)

	// Basic information
	pdf.SetFont("Arial", "B", 12)
	pdf.Cell(40, 10, "Summary of Analysis")
	pdf.Ln(10)

	pdf.SetFont("Arial", "", 11)

	// Extract and add packet count
	var packetCount int
	fmt.Sscanf(result, "Processed %d packets", &packetCount)
	pdf.Cell(40, 10, fmt.Sprintf("Packets Processed: %d", packetCount))
	pdf.Ln(10)

	// Check if threats were detected
	if strings.Contains(result, "no threats detected") {
		pdf.Cell(40, 10, "No threats were detected in the analyzed packet capture.")
		pdf.Ln(10)
	} else {
		// Extract threats
		threatStart := strings.Index(result, "detected threats: ")
		if threatStart != -1 {
			threatStart += len("detected threats: ")
			threatEnd := strings.Index(result[threatStart:], "\n")
			if threatEnd == -1 {
				threatEnd = len(result[threatStart:])
			}

			threatsPart := result[threatStart : threatStart+threatEnd]
			threatsPart = strings.Trim(threatsPart, "[]")

			pdf.Cell(40, 10, "Detected Threats:")
			pdf.Ln(8)

			threats := strings.Split(threatsPart, ", ")
			for _, threat := range threats {
				threat = strings.TrimSpace(threat)
				if threat != "" {
					pdf.Cell(40, 8, "â€¢ "+threat)
					pdf.Ln(8)
				}
			}
			pdf.Ln(5)
		}

		// Add a summary section
		pdf.SetFont("Arial", "B", 12)
		pdf.Cell(40, 10, "Overall Analysis")
		pdf.Ln(10)

		pdf.SetFont("Arial", "", 11)
		// Extract the OpenAI analysis
		analysisStart := strings.Index(result, "Analysis:")
		if analysisStart != -1 {
			analysisText := result[analysisStart+len("Analysis:"):]

			// Get the first paragraph as summary (up to 300 characters)
			summary := analysisText
			if len(summary) > 300 {
				summary = summary[:300] + "..."
			}

			// Format summary text for PDF
			pdf.MultiCell(0, 6, strings.TrimSpace(summary), "", "", false)
			pdf.Ln(10)
		}

		// Add detailed section for chunks
		pdf.SetFont("Arial", "B", 12)
		pdf.Cell(40, 10, "Detailed Analysis by Chunk")
		pdf.Ln(10)

		// Extract chunks and their analyses
		chunks := extractChunks(result)

		for i, chunk := range chunks {
			pdf.SetFont("Arial", "B", 11)
			pdf.Cell(40, 10, fmt.Sprintf("Chunk %d", i+1))
			pdf.Ln(8)

			pdf.SetFont("Arial", "", 10)
			pdf.MultiCell(0, 5, strings.TrimSpace(chunk), "", "", false)
			pdf.Ln(8)
		}
	}

	// Add footer
	pdf.SetY(-20)
	pdf.SetFont("Arial", "I", 8)
	pdf.Cell(0, 10, "Generated by PacketGuardian-LLM")

	// Create a buffer to store the PDF
	var buf bytes.Buffer

	// Write the PDF to the buffer
	err := pdf.Output(&buf)
	if err != nil {
		return nil, err
	}

	// Return the PDF as bytes
	return buf.Bytes(), nil
}

// extractChunks extracts individual chunk analyses from the result string
func extractChunks(result string) []string {
	// Look for chunk analyses in the format "Analysis for malicious_chunk_X.json: ..."
	var chunks []string

	// Split by chunk markers
	chunkMarkers := strings.Split(result, "Analysis for malicious_chunk_")

	// Skip the first part which is before any chunk
	if len(chunkMarkers) > 1 {
		for i := 1; i < len(chunkMarkers); i++ {
			chunkText := chunkMarkers[i]

			// Extract chunk number and content
			parts := strings.SplitN(chunkText, ".json:", 2)
			if len(parts) == 2 {
				chunkContent := parts[1]
				chunks = append(chunks, chunkContent)
			}
		}
	} else {
		// If no chunks were found, use the entire analysis
		analysisStart := strings.Index(result, "Analysis:")
		if analysisStart != -1 {
			chunks = append(chunks, result[analysisStart+len("Analysis:"):])
		}
	}

	return chunks
}
